use itertools::Itertools;
use serde::{
    de::{Deserializer, Error},
    Deserialize,
    Serialize,
    Serializer,
};
use serde_diff::SerdeDiff;
use std::fmt::{self};

pub type ContributorId = String;
pub type VerifierId = String;

/// A participant in the setup ceremony. The participant can either be
/// a [Participant::Contributor] or a [Participant::Verifier].
#[derive(Clone, Eq, PartialEq, Hash, SerdeDiff)]
pub enum Participant {
    /// A contributor is a ceremony participant that makes active
    /// contributions during the setup ceremony.
    Contributor(ContributorId),
    /// A verifier is a ceremony participant that verifies the
    /// contributions made by [Participant::Contributor]s.
    Verifier(VerifierId),
}

impl Participant {
    /// Creates a new contributor instance of `Participant`.
    pub fn new_contributor(participant: &str) -> Self {
        Participant::Contributor(participant.to_string())
    }

    /// Creates a new verifier instance of `Participant`.
    pub fn new_verifier(participant: &str) -> Self {
        Participant::Verifier(participant.to_string())
    }

    /// Returns `true` if the participant is a contributor.
    /// Otherwise, returns `false`.
    pub fn is_contributor(&self) -> bool {
        match self {
            Participant::Contributor(_) => true,
            Participant::Verifier(_) => false,
        }
    }

    /// Returns `true` if the participant is a verifier.
    /// Otherwise, returns `false`.
    pub fn is_verifier(&self) -> bool {
        !self.is_contributor()
    }

    /// Retrieve the address of the participant.
    pub fn address(&self) -> String {
        match self {
            Participant::Contributor(a) => a.to_string(),
            Participant::Verifier(a) => a.to_string(),
        }
    }
}

impl fmt::Display for Participant {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Participant::Contributor(contributor_id) => write!(f, "{}.contributor", contributor_id),
            Participant::Verifier(verifier_id) => write!(f, "{}.verifier", verifier_id),
        }
    }
}

impl fmt::Debug for Participant {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Participant::Contributor(contributor_id) => write!(f, "{}.contributor", contributor_id),
            Participant::Verifier(verifier_id) => write!(f, "{}.verifier", verifier_id),
        }
    }
}

impl Serialize for Participant {
    fn serialize<S: Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        match self {
            Participant::Contributor(id) => serializer.serialize_str(&format!("{}.contributor", id)),
            Participant::Verifier(id) => serializer.serialize_str(&format!("{}.verifier", id)),
        }
    }
}

impl<'de> Deserialize<'de> for Participant {
    fn deserialize<D: Deserializer<'de>>(deserializer: D) -> Result<Participant, D::Error> {
        let s = String::deserialize(deserializer)?;

        let (id, participant_type) = s
            .splitn(2, ".")
            .collect_tuple()
            .ok_or(D::Error::custom("unknown participant type"))?;
        let participant = match participant_type {
            "contributor" => Participant::Contributor(id.to_string()),
            "verifier" => Participant::Verifier(id.to_string()),
            _ => return Err(D::Error::custom("unknown participant type")),
        };

        Ok(participant)
    }
}
